<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEISHOT - 3D Card Result</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;800&family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #f0f4f8; /* 初期背景色 */
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
        }
        .overlay-ui {
            position: absolute;
            pointer-events: none;
        }
        .interactive {
            pointer-events: auto;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <div class="overlay-ui inset-0 flex flex-col justify-between p-6">
        <div class="flex justify-between items-start">
            <div>
                <h1 class="text-gray-800 text-2xl font-extrabold tracking-tight drop-shadow-sm">
                    <span class="text-transparent bg-clip-text bg-gradient-to-r from-[#ff7e5f] to-[#feb47b]">MEISHOT</span>
                    RESULT
                </h1>
                <p class="text-gray-500 text-sm mt-1"><i class="fas fa-hand-pointer mr-1"></i> ドラッグして回転</p>
            </div>
            
            <div class="bg-white/80 backdrop-blur-md text-gray-600 px-4 py-2 rounded-full border border-gray-200 text-xs shadow-sm">
                Generated: 2026.02.09
            </div>
        </div>

        <div class="flex justify-center items-end gap-4 pb-8">
            <button class="interactive bg-white hover:bg-gray-50 text-gray-700 px-6 py-3 rounded-full font-bold transition-all transform hover:scale-105 shadow-lg border border-gray-200 flex items-center gap-2">
                <i class="fas fa-redo"></i>
                もう一度撮る
            </button>
            <button class="interactive bg-gradient-to-r from-[#ff7e5f] to-[#feb47b] hover:shadow-orange-500/50 text-white px-8 py-3 rounded-full font-bold shadow-lg transition-all transform hover:scale-105 flex items-center gap-2">
                <i class="fas fa-wallet"></i>
                ウォレットに保存
            </button>
        </div>
    </div>

    <script>
        // --- 設定 ---
        // 修正: 裏面画像を1枚の生成画像に変更
        const IMG_BACK = 'Gemini_Generated_Image_hxtpeehxtpeehxtp.png';
        const IMG_LOGO = 'アセット 3@4x.png'; // ロゴ画像

        // 名刺サイズ比率 (91mm x 55mm)
        const CARD_WIDTH = 9.1;
        const CARD_HEIGHT = 5.5;
        // 修正: 厚みを0.05から0.15に変更して存在感をアップ
        const CARD_DEPTH = 0.15;
        const CARD_RADIUS = 0.3; // 角丸の半径

        let scene, camera, renderer, cardMesh;
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        window.onload = function() {
            init3D();
            animate();
        };

        function init3D() {
            scene = new THREE.Scene();
            // 背景色を白っぽく変更 (#f0f4f8)
            scene.background = new THREE.Color(0xf0f4f8);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 18;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // ライティング
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(5, 10, 7);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // --- テクスチャ生成 ---
            const textureLoader = new THREE.TextureLoader();

            // 1. 表面（ビジネス情報）
            const frontCanvas = document.createElement('canvas');
            frontCanvas.width = 1024;
            frontCanvas.height = 619; // 91:55比率に合わせる
            const ctxF = frontCanvas.getContext('2d');
            
            // ★修正: 先にテクスチャオブジェクトを作成する
            const frontTexture = new THREE.CanvasTexture(frontCanvas);
            frontTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();

            // ロゴ画像のオブジェクトを保持
            let loadedLogoImg = null;

            // 表面全体の描画関数 (2重描画防止のため、毎回クリアしてから描く)
            function renderFrontCard() {
                // 1. 背景クリア（白で塗りつぶし）
                ctxF.fillStyle = '#ffffff';
                ctxF.fillRect(0, 0, 1024, 619);

                // 2. ロゴがあれば描画
                if (loadedLogoImg) {
                    const logoHeight = 350; 
                    const scale = logoHeight / loadedLogoImg.height;
                    const logoWidth = loadedLogoImg.width * scale;
                    
                    // 右寄せ配置 (右端から50pxあける)
                    const x = 1024 - logoWidth - 50;
                    const y = (619 - logoHeight) / 2; // 上下中央
                    ctxF.drawImage(loadedLogoImg, x, y, logoWidth, logoHeight);
                } else {
                    // ロゴがない/ロード中ならダミーを表示しない（シンプルにする）
                    // 必要ならここにダミー円描画
                }

                // 3. テキスト描画
                // 名前
                ctxF.fillStyle = '#333333';
                ctxF.font = 'bold 80px "Noto Sans JP"';
                ctxF.fillText('猪原 大智', 60, 180);

                // 肩書き
                ctxF.fillStyle = '#666666';
                ctxF.font = '500 32px "Noto Sans JP"';
                ctxF.fillText('筑波大学情報メディア創成学類', 60, 240);

                // 連絡先情報
                ctxF.fillStyle = '#555555';
                ctxF.font = '30px "Noto Sans JP"';
                const lineHeight = 50;
                let startY = 400;

                ctxF.fillText('Tel: 070-XXXX-XXXX', 60, startY);
                ctxF.fillText('Email: s2210036@u.tsukuba.ac.jp', 60, startY + lineHeight);
                ctxF.fillText('Web: inotai.net', 60, startY + lineHeight * 2);

                // テクスチャ更新通知
                frontTexture.needsUpdate = true;
            }

            // ロゴ画像の読み込み開始
            const logoImg = new Image();
            logoImg.crossOrigin = "anonymous";
            logoImg.onload = () => {
                loadedLogoImg = logoImg;
                renderFrontCard(); // ロード完了後に再描画
            };
            logoImg.onerror = () => {
                console.log("Logo load failed");
                renderFrontCard(); // 失敗してもテキストは描画
            };
            logoImg.src = IMG_LOGO;

            // 初回描画（ロゴロード前）
            renderFrontCard();


            // 2. 裏面（生成された画像）
            const backCanvas = document.createElement('canvas');
            backCanvas.width = 1024;
            backCanvas.height = 619;
            const ctxB = backCanvas.getContext('2d');

            ctxB.fillStyle = '#222';
            ctxB.fillRect(0, 0, 1024, 619);

            // ★修正: 裏面も先にテクスチャオブジェクトを作成
            const backTexture = new THREE.CanvasTexture(backCanvas);
            backTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            
            // 修正: 1枚の画像を読み込んでフィットさせる
            const backImg = new Image();
            backImg.crossOrigin = "anonymous";
            
            backImg.onload = () => {
                // キャンバス全体に描画（リサイズしてフィット）
                ctxB.drawImage(backImg, 0, 0, 1024, 619);
                
                // もし「アスペクト比維持」で黒帯が出ても良いなら以下のロジックを使うが、
                // 「フィット」の要望なので引き伸ばし、または object-cover 的な処理をする。
                // 今回はシンプルに全体を引き伸ばして埋めます（名刺サイズの画像と想定）。
                
                // タイトル文字などを重ねたい場合はここに記述
                // ctxB.fillStyle = '#ffcc00'; ...
                
                backTexture.needsUpdate = true;
            };
            
            backImg.onerror = () => {
                // エラー時の表示
                ctxB.fillStyle = '#333';
                ctxB.fillRect(0,0,1024,619);
                ctxB.fillStyle = '#fff';
                ctxB.font = '30px Arial';
                ctxB.textAlign = 'center';
                ctxB.fillText('Image Load Failed', 512, 310);
                backTexture.needsUpdate = true;
            };

            backImg.src = IMG_BACK;


            // --- ジオメトリ生成 (角丸対応) ---
            const shape = new THREE.Shape();
            const w = CARD_WIDTH;
            const h = CARD_HEIGHT;
            const r = CARD_RADIUS; 
            const x = -w / 2;
            const y = -h / 2;

            // 角丸長方形のパスを作成
            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            // 押し出し設定
            const extrudeSettings = {
                depth: CARD_DEPTH,
                bevelEnabled: false, // ベベル（面取り）は無効化してシャープに
                steps: 1
            };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            // UVマッピングの修正
            geometry.computeBoundingBox();
            const max = geometry.boundingBox.max;
            const min = geometry.boundingBox.min;
            const offset = new THREE.Vector2(0 - min.x, 0 - min.y);
            const range = new THREE.Vector2(max.x - min.x, max.y - min.y);

            const uvAttribute = geometry.attributes.uv;
            for (let i = 0; i < uvAttribute.count; i++) {
                const u = uvAttribute.getX(i);
                const v = uvAttribute.getY(i);
                uvAttribute.setXY(i, (u + offset.x) / range.x, (v + offset.y) / range.y);
            }
            geometry.attributes.uv.needsUpdate = true;

            // --- マテリアル割り当て ---
            // 法線計算
            geometry.computeVertexNormals();

            // マテリアル
            const matFront = new THREE.MeshBasicMaterial({ map: frontTexture });
            const matBack = new THREE.MeshBasicMaterial({ map: backTexture }); 
            const matSide = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 }); 

            // ベース（紙）
            const baseMesh = new THREE.Mesh(geometry, matSide);
            
            // 表面の画像プレート
            const planeGeo = new THREE.ShapeGeometry(shape);
            // UV再計算
            planeGeo.computeBoundingBox();
            const pMax = planeGeo.boundingBox.max;
            const pMin = planeGeo.boundingBox.min;
            const pOffset = new THREE.Vector2(0 - pMin.x, 0 - pMin.y);
            const pRange = new THREE.Vector2(pMax.x - pMin.x, pMax.y - pMin.y);
            const pUv = planeGeo.attributes.uv;
            for(let i=0; i<pUv.count; i++){
                pUv.setXY(i, (pUv.getX(i)+pOffset.x)/pRange.x, (pUv.getY(i)+pOffset.y)/pRange.y);
            }

            const frontMesh = new THREE.Mesh(planeGeo, matFront);
            frontMesh.position.z = CARD_DEPTH + 0.001; // 手前に配置

            // 裏面の画像プレート
            const backMesh = new THREE.Mesh(planeGeo, matBack);
            backMesh.rotation.y = Math.PI; // 裏返す
            // 画像反転補正
            backTexture.center.set(0.5, 0.5);
            backTexture.repeat.set(-1, 1);
            
            backMesh.position.z = 0 - 0.001; // 奥に配置

            // グループ化
            cardMesh = new THREE.Group();
            cardMesh.add(baseMesh); // 厚み部分
            cardMesh.add(frontMesh); // 表面
            cardMesh.add(backMesh); // 裏面

            baseMesh.position.z = 0; 

            // グループ全体をシーンに追加
            scene.add(cardMesh);

            // 初期回転
            cardMesh.rotation.y = -0.5;
            cardMesh.rotation.x = 0.2;

            // イベント
            const container = document.getElementById('canvas-container');
            container.addEventListener('mousedown', onMouseDown, false);
            container.addEventListener('touchstart', onTouchStart, false);
            window.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('touchend', onMouseUp, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('touchmove', onTouchMove, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = { x: event.clientX, y: event.clientY };
        }
        function onTouchStart(event) {
            if(event.touches.length === 1) {
                isDragging = true;
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
        }
        function onMouseUp(event) { isDragging = false; }
        function onMouseMove(event) {
            if (isDragging) {
                const deltaMove = { x: event.clientX - previousMousePosition.x, y: event.clientY - previousMousePosition.y };
                cardMesh.rotation.y += deltaMove.x * 0.01;
                cardMesh.rotation.x += deltaMove.y * 0.01;
                previousMousePosition = { x: event.clientX, y: event.clientY };
            }
        }
        function onTouchMove(event) {
            if (isDragging && event.touches.length === 1) {
                event.preventDefault();
                const deltaMove = { x: event.touches[0].clientX - previousMousePosition.x, y: event.touches[0].clientY - previousMousePosition.y };
                cardMesh.rotation.y += deltaMove.x * 0.01;
                cardMesh.rotation.x += deltaMove.y * 0.01;
                previousMousePosition = { x: event.touches[0].clientX, y: event.touches[0].clientY };
            }
        }
    </script>
</body>
</html>